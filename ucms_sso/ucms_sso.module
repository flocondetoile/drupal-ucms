<?php
/**
 * @file
 * UCMS - Pseudo SSO accross sites.
 *
 * 1) User already connected on site SSO:
 * 
 * Browser             Site X     Site SSO  cache(shared)
 *  |  GET /foo (ano.)    |           |
 *  |-------------------->|           |
 *  |   foo + sso js      |           |   token+domain:
 *  |<--------------------|           |  [session id +
 *  | Ajax /sso/check (+credentials)  |   IP + domain]
 *  |-------------------------------->|------>|
 *  |     json (one time token)       |       |
 *  |<--------------------------------|       |
 *  |GET /sso/login/token |                   |
 *  |-------------------->|  token + domain   |
 *  |                     |------------------>|
 *  |                     |    session_id     |
 *  |                     |<------------------|
 *  |  302 + session_id   |  here we also check the user IP
 *  |<--------------------|  is the same and sends the session_id
 *  |  get /foo (session) |  as a valid X domain cookie.
 *  |-------------------->|
 *  | foo (authenticated) |
 *  |<--------------------|
 * The user, having a valid session id (credentials) on SSO domain
 * will automatically be connected on site X, with, at the end, a
 * valid PHP session on domain X (using same session id as the one used
 * on SSO domain).
 * - token can only be used 1 time.
 * - token has a short validity (1 minute)
 * - token can only be used on the Site X domain (using Ajax Origin header)
 * - site X domain is checked out, to be a domain managed by the factory only.
 *
 * 2) user is not yet connected
 * Browser             Site X     Site SSO
 *  |  GET /foo (ano.)    |           |
 *  |-------------------->|           |
 *  |   foo + sso js      |           |
 *  |<--------------------|           |
 *  | Ajax /sso/check (no creds)      |
 *  |-------------------------------->|
 *  |     refusal                     |
 *  |<--------------------------------|
 *  | (main anonymous page is unaltered)
 *  |
 *   \--> TODO: login link/page should redirect to master domain
 *   \--> TODO: login link should first send an ajax query to /sso/check
 *                    to check that the user been recently connected
 *  TODO: remove the js retry loop
 *  TODO: ensure the refusal page for anonymous check on /sso/check can be cached by Varnish
 */

/**
 * Implements hook_menu().
 */
function ucms_sso_menu() {
  $items = [];

  $items['sso/check'] = [
    'page callback'     => 'ucms_sso_callback_check',
    'access callback'   => true,
    'type'              => MENU_CALLBACK,
  ];
  $items['sso/login'] = [
    'page callback'     => 'ucms_sso_callback_login',
    'access callback'   => 'user_is_anonymous',
    'type'              => MENU_CALLBACK,
  ];

  return $items;
}

/**
 * Get default URL scheme. Later will always be 'https'.
 */
function ucms_sso_scheme_get() {
  // @todo only https later
  return $GLOBALS['is_https'] ? 'https' : 'http';
}

/**
 * Tells if the current site is master.
 *
 * @return boolean
 */
function ucms_sso_is_master() {
  return !ucms_site_manager()->getContext() && !drupal_is_cli() && $_SERVER['HTTP_HOST'] === variable_get('ucms_site_master_hostname');
}

/**
 * Get a valid HTTP Origin header if it matches an existing site.
 *
 * @return boolean
 */
function ucms_sso_origin_get() {
  if (!empty($_SERVER['HTTP_ORIGIN'])) {
    $manager = ucms_site_manager();
    $site = $manager->getStorage()->findByHostname($_SERVER['HTTP_ORIGIN']);
    if ($site && $manager->getAccess()->userCanView($site)) {
      return $site->http_host;
    }
  }
}

/**
 * Implements hook_init().
 */
function ucms_sso_init() {
  if (ucms_sso_is_master()) {
    if ($origin = ucms_sso_origin_get()) {
      // we had an origin in the request query, should not happen with images or classical pages
      // so we can be quite sure this was an ajax request
      // We need to allow modern browsers to send cookies on theses ajax cross domain requests
      // Note that Access-Control-Allow-Origin: * would not work with credentials, so we
      // also need to send a domain specific authorization.
      // the ucms_sso_origin_get() made the check about validity of this origin.
      drupal_add_http_header('Access-Control-Allow-Origin', ucms_sso_scheme_get() . '://' . $origin);
      drupal_add_http_header('Access-Control-Allow-Credentials', 'true');
      drupal_add_http_header('Access-Control-Allow-Headers', 'Accept, Content-Type');
      drupal_add_http_header('Access-Control-Allow-Methods', 'OPTIONS, GET, POST');
    }

  } else {
    // If there is no origin in the HTTP headers, this means we are building
    // a full web page, then we need to add this JS.
    if (!user_is_logged_in() && ($data = ucms_sso_js())) {
      drupal_add_js($data, ['type' => 'inline', 'scope' => 'header']);
    }
  }
}

/**
 * (Not really an) SSO callback.
 */
function ucms_sso_callback_check() {
  if (!$origin = ucms_sso_origin_get()) {
    return MENU_ACCESS_DENIED;
  }
  if (!user_is_logged_in()) {
  // TODO: if no credentials were sent, that's a purely anonymous check, the refusal response could be cacheable by varnish
    return MENU_ACCESS_DENIED;
  }
  // User 42 is logged on site A (master).
  // User 42 goes on site B (slave).
  // Site B does an AJAX request on A (this callback).
  //  - Token exists: it returns OK, then redirect the client on itself
  //    with session id as token on site B (the next callback).
  //  - Token is wrong: it returns NO, a JavaScript cookie is set and it
  //    prevents the user from loggin in for a few minutes.

  // generate one-time-token for the user, bind to the origin and ip adress
  // the token also depends on the current session_id
  $user_ip =  ip_address();
  $sso_record = array(
      'ip' => $user_ip,
      'origin' => $origin,
      'session' => session_id(),
      'validity' => REQUEST_TIME + 60,
  );
  $hmac = hash_hmac('sha256',
                    $sso_record['ip'] . $sso_record['origin'] . $sso_record['session'] . $sso_record['validity'],
                    variable_get('ucms_sso_token_salt','please_edit_settings_file_to_alter_salt'),
                    FALSE);
  $one_time_token = $hmac;
  $cache_key = 'sso_checkx' . $origin .'x'. $hmac;
  cache_set($cache_key, $sso_record, 'cache_sso', $sso_record['validity']);
  return drupal_json_output(['status' => 1, 'uri' => ucms_sso_scheme_get() . '://' . $origin . '/sso/login/?s=' . $one_time_token]);
}

/**
 * (Not really an) SSO callback.
 */
function ucms_sso_callback_login() {
  if (empty($_GET['s'])) {
    return MENU_ACCESS_DENIED;
  }

  $hmac = $_GET['s'];
  if (!ctype_xdigit($hmac)) {
    return MENU_ACCESS_DENIED;
  }

  // retrieve stored temporary token storage
  $domain = $_SERVER['HTTP_HOST'];
  $cache_key = 'sso_checkx' . $domain .'x'. $hmac;
  $cache_entry = cache_get($cache_key, 'cache_sso');
  if (!isset($cache_entry) || !$cache_entry) {
    return MENU_ACCESS_DENIED;
  }

  $sso_record = $cache_entry->data;

  // ALWAYS invalidate this token for future use
  // that's a ONE TIME thing
  cache_set($cache_key, $sso_record, 'cache_sso', REQUEST_TIME);

  // check that this record was for this site, this IP, and with a good validity
  $user_ip =  ip_address();
  if ($user_ip != $sso_record['ip'] ||
      $domain != $sso_record['origin'] ||
      $sso_record['validity'] < REQUEST_TIME) {
    // reject user
    return MENU_ACCESS_DENIED;
  }

  $sessionId = $sso_record['session'];

  // Set the new session cookie on this domain, which is in fact the same as the master domain session
  setcookie(session_name(), false);
  $params = session_get_cookie_params();
  $expire = $params['lifetime'] ? REQUEST_TIME + $params['lifetime'] : 0;
  setcookie(session_name(), $sessionId, $expire, $params['path'], $params['domain'], $params['secure'], $params['httponly']);
  // Leave the user to the page he sould be.
  drupal_goto();
}

/**
 * Get the SSO javascript.
 */
function ucms_sso_js() {

  $masterHostname = variable_get('ucms_site_master_hostname');

  if (!$masterHostname) {
    return;
  }

  $master = url(ucms_sso_scheme_get() . '://' . $masterHostname . '/sso/check');

  // This is the packed version, please note that you want to edit the
  // ucms_sso.js instead, then pack it using http://dean.edwards.name/packer/
  // in which case, don't worry about the ${master}, it will be left untouched
  // by the packer.
  return <<<EOT
(function(){"use strict";var d=document;function n(){return Math.floor(Date.now()/1000)}function stop(){d.cookie="usso="+(n()+240)}function may(){var a=d.cookie.match(/usso=([\d]+)(;|$)/);return!a||a[1]<n()}if(may()){var x=new XMLHttpRequest();x.open("GET","${master}");x.withCredentials=true;x.setRequestHeader("Accept","application/json");x.onerror=function(){stop()};x.onload=function(){try{var d=JSON.parse(this.responseText);if(d.status&&d.uri){window.location.href=d.uri+"&destination="+window.location.href}stop()}catch(e){stop()}};x.send()}}());
EOT;
}

<?php
/**
 * @file
 * UCMS - Site context and management.
 *
 * @todo
 *   - Implement variables overloading for site: name, home
 */

use MakinaCorpus\Ucms\Site\Access;
use MakinaCorpus\Ucms\Site\State;

/**
 * Implements hook_menu().
 */
function ucms_site_menu() {
  $items = [];

  $items['admin/dashboard/site'] = [
    'title'             => "Sites",
    'page callback'     => 'ucms_site_dashboard_site_list',
    'access arguments'  => [Access::PERM_SITE_DASHBOARD_ACCESS],
    'type'              => MENU_NORMAL_ITEM,
    'file'              => 'ucms_site.dashboard.inc',
  ];
  $items['admin/dashboard/site/request'] = [
    'title'             => "Request new site",
    'page callback'     => 'sf_dic_page_form',
    'page arguments'    => ['MakinaCorpus\Ucms\Site\Form\SiteRequest'],
    'access arguments'  => [Access::PERM_SITE_REQUEST],
    'type'              => MENU_NORMAL_ITEM,
  ];
  $items['admin/dashboard/site/%ucms_site'] = [
    'title'             => "Site overview",
    'page callback'     => 'ucms_site_dashboard_site_page_view',
    'page arguments'    => [3],
    'access callbacks'  => 'ucms_site_access_manage',
    'access arguments'  => [3],
    'type'              => MENU_NORMAL_ITEM,
    'file'              => 'ucms_site.dashboard.inc',
  ];
  $items['admin/dashboard/site/%ucms_site/view'] = [
    'title'             => "Information",
    'type'              => MENU_DEFAULT_LOCAL_TASK,
  ];
  $items['admin/dashboard/site/%ucms_site/log'] = [
    'title'             => "Log",
    'page callback'     => 'ucms_site_dashboard_site_page_log',
    'page arguments'    => [3],
    'access callbacks'  => 'ucms_site_access_manage',
    'access arguments'  => [3],
    'type'              => MENU_LOCAL_TASK,
    'file'              => 'ucms_site.dashboard.inc',
  ];
  $items['admin/dashboard/site/%ucms_site/webmasters'] = [
    'title'             => "Webmasters",
    'page callback'     => 'ucms_site_dashboard_site_page_webmasters',
    'page arguments'    => [3],
    'access callbacks'  => 'ucms_site_access_manage',
    'access arguments'  => [3],
    'type'              => MENU_LOCAL_TASK,
    'file'              => 'ucms_site.dashboard.inc',
  ];
  $items['admin/dashboard/site/%ucms_site/edit'] = [
    'title'             => "Site edit",
    'page callback'     => 'drupal_get_form',
    'page arguments'    => ['ucms_site_dashboard_site_edit_form', 3],
    'access callbacks'  => 'ucms_site_access_manage',
    'access arguments'  => [3],
    'type'              => MENU_CALLBACK | MENU_VISIBLE_IN_BREADCRUMB,
    'file'              => 'ucms_site.dashboard.inc',
  ];
  $items['admin/dashboard/site/%ucms_site/delete'] = [
    'title'             => "Site edit",
    'page callback'     => 'drupal_get_form',
    'page arguments'    => ['ucms_site_dashboard_site_delete_form', 3],
    'access callbacks'  => 'ucms_site_access_manage',
    'access arguments'  => [3],
    'type'              => MENU_CALLBACK | MENU_VISIBLE_IN_BREADCRUMB,
    'file'              => 'ucms_site.dashboard.inc',
  ];

  return $items;
}

/**
 * Implements hook_permission().
 */
function ucms_site_permission() {
  return [
    Access::PERM_GLOBAL_VIEW => [
      'title' => t("View global content"),
    ],
    Access::PERM_GLOBAL_EDIT => [
      'title' => t("Edit global content"),
    ],
    Access::PERM_GLOBAL_LABELED_VIEW => [
      'title' => t("View global labeled content"),
    ],
    Access::PERM_GLOBAL_LABELED_EDIT => [
      'title' => t("Edit global labeled content"),
    ],
    Access::PERM_SITE_REQUEST => [
      'title' => t("Request new site"),
    ],
    Access::PERM_SITE_DASHBOARD_ACCESS => [
      'title' => t("Access to site dashboard"),
    ],
    Access::PERM_SITE_MANAGE_ALL => [
      'title' => t("Manage all sites no matter their state is"),
    ],
    Access::PERM_SITE_VIEW_ALL => [
      'title' => t("View all sites no matter their state is"),
    ],
  ];
}

/**
 * Get site finder service.
 *
 * @return \MakinaCorpus\Ucms\Site\SiteFinder
 */
function ucms_site_finder() {
  return \Drupal::service('ucms_site_finder');
}

/**
 * Get site access service.
 *
 * @return \MakinaCorpus\Ucms\Site\SiteAccessService
 */
function ucms_site_access() {
  return \Drupal::service('ucms_site_access');
}

/**
 * Menu helper.
 */
function ucms_site_load($id) {
  try {
    return ucms_site_finder()->findOne($id);
  } catch (\InvalidArgumentException $e) {
    return false;
  }
}

/**
 * Menu helper.
 */
function ucms_site_access_manage($site, $account = null) {
  if (!$site instanceof Site) {
    return false;
  }
  if (!$account) {
    $account = $GLOBALS['user'];
  }
  return ucms_site_access()->userCanManage($site, $account->uid);
}

/**
 * Implements hook_boot().
 */
function ucms_site_boot() {

  // hook_boot() is the perfect place to set any context long before anything
  // else get initialized (except locale).
  if (!empty($_SERVER['HTTP_HOST'])) {
    ucms_site_finder()->findByHostname($_SERVER['HTTP_HOST'], true);
  }

  // @todo Else attempt to find another contextual information (GET parameter?)
  // in order to determine preview mode or not.
}

/**
 * Implements hook_menu_site_status_alter().
 */
function ucms_site_menu_site_status_alter(&$menu_site_status, $path) {

  global $user;

  // Do not alter an already offline site
  if (MENU_SITE_OFFLINE === $menu_site_status) {
    return;
  }

  $site = ucms_site_finder()->getContext();

  if (!$site) {
    return; // No site in context, nothing to check for.
  }
  if (State::ON == $site->state) {
    return; // Normal runtime operation, nothing to do.
  }

  if (!ucms_site_access()->userCanView($site, $user->uid)) {
    $menu_site_status = MENU_SITE_OFFLINE;
    // State off means that the site is valid and up, but in maintainance mode,
    // case in which we should just set the maintainance mode and leave,
    // otherwise would mean that the site is neither ON nor OFF and does not
    // exist for the outside, so redirect to something that exists (the main
    // site). If we have nothing to redirect to, at least this code will
    // fallback on site being offline.
    if (State::OFF != $site->state) {
      if ($uri = variable_get('ucms_site.redirect.uri')) {
        drupal_goto($uri, [], variable_get('ucms_site.redirect.http_code', 307));
      }
    }
  }
}

/**
 * Implements hook_init().
 */
function ucms_site_init() {
  // We might have some problems due to the fact that the site is determined
  // at hook_boot() time, for example, we cannot call the path_is_admin()
  // function because modules have not been invoked. Site is being set way
  // before at hook_boot() in order to ensure that everything actually using
  // this information until now does it right (they should only be revelant
  // for frontend anyway), but we have a chance right now to fix admin paths
  // and remove the site information right now.
  if (path_is_admin(current_path())) {
    ucms_site_finder()->dropContext();

    // Also redirect on the main dashboard.
    // @todo Needs a variable with the factory site URL.
  }
}

/**
 * Implements hook_custom_theme().
 */
function ucms_site_custom_theme() {

  // This should be called way after the hook_init() run, so we are sure the
  // site has been rightly set, and if we are in admin site has been removed,
  // so if we have a site structure, we are 100% sure we are not in an admin
  // path.
  $site = ucms_site_finder()->getContext();

  if (!$site) {
    return;
  }
  if (!$site->theme) {
    return;
  }

  // Ensure the theme is enabled for security, Drupal won't do it for
  // you, you might experience surprises. There is sadly no shortcut
  // we have to iterate over the full list of themes.
  foreach (list_themes() as $name => $data) {
    if ($site->theme === $name && $data->status) {
      return $site->theme;
    }
  }
}

/**
 * Implements hook_node_load().
 */
function ucms_site_node_load($nodes, $types) {

  // Attach site identifiers list to each node being loaded. Althought it does
  // and extra SQL query, this being the core of the whole site business, we
  // can't bypass this step nor risk it being stalled with unsynchronized data
  // in cache.

  // @todo Later in the future, determiner an efficient way of caching it,
  // we'll need this data to be set in Elastic Search anyway so we'll risk data
  // stalling in there.

  $r = db_select('ucms_site_node', 'usn')
    ->fields('usn', ['nid', 'site_id'])
    ->condition('usn.nid', array_keys($nodes))
    ->orderBy('usn.nid')
    ->execute()
  ;

  foreach ($r as $row) {
    $node = $nodes[$row->nid];
    if (!property_exists($node, 'ucms_sites')) {
      $node->ucms_sites = [];
    }
    $node->ucms_sites[] = $row->site_id;
  }
}

/**
 * Implements hook_node_access().
 */
function ucms_site_node_access($node, $op, $account) {

  if (is_string($node)) {
    if ('create' === $op) {
      // @todo Check creation permissions;
    }
    return NODE_ACCESS_DENY;
  }

  $grants   = ucms_site_node_grants($account, $op);
  $records  = ucms_site_node_access_records($node);
  $prop     = 'grant_' . $op;

  foreach ($records as $record) {

    if (empty($record[$prop])) {
      continue;
    }

    foreach ($grants as $realm => $gids) {
      if ($realm === $record['realm'] && in_array($record['gid'], $gids)) {
        return NODE_ACCESS_ALLOW;
      }
    }
  }

  return NODE_ACCESS_DENY;
}

/**
 * Implements hook_node_access_records().
 */
function ucms_site_node_access_records($node) {
  $ret = [];

  // This is where it gets complicated.
  $isGlobal = false;

  if ($node->is_global) {
    // Node is in the global base.
    $isGlobal = true;

    $ret[] = array(
      'realm'         => Access::REALM_GLOBAL_LABELED,
      'gid'           => Access::GID_DEFAULT,
      'grant_view'    => 1,
      'grant_update'  => 1,
      'grant_delete'  => 1,
      'priority'      => Access::PRIORITY_DEFAULT,
    );

    if (false /* @todo Node is labeled */) {
      // Node is labeled.
      $ret[] = array(
        'realm'         => Access::REALM_GLOBAL,
        'gid'           => Access::GID_DEFAULT,
        'grant_view'    => 1,
        'grant_update'  => 0,
        'grant_delete'  => 0,
        'priority'      => Access::PRIORITY_DEFAULT,
      );
    } else {
      // Node is not labeled.
      $ret[] = array(
        'realm'         => Access::REALM_GLOBAL,
        'gid'           => Access::GID_DEFAULT,
        'grant_view'    => 1,
        'grant_update'  => 1,
        'grant_delete'  => 1,
        'priority'      => Access::PRIORITY_DEFAULT,
      );
    }
  }

  // Inject an entry for each site, even when the node is a global node, this
  // will tell the Drupal API system if the node is visible or not inside a
  // local site. Please note that we will never add the site state as a node
  // grant, this will be determined at runtime: the reason for this is that if
  // you change a site state, you would need to rebuild all its nodes grants
  // and this would not be tolerable.
  if (property_exists($node, 'ucms_sites')) {

    // A node in any site and published should be visible by users.
    $ret[] = array(
      'realm'         => Access::REALM_PUBLIC,
      'gid'           => Access::GID_DEFAULT,
      'grant_view'    => $node->status,
      'grant_update'  => 0,
      'grant_delete'  => 0,
      'priority'      => Access::PRIORITY_DEFAULT,
    );

    foreach ($node->ucms_sites as $siteId) {
      $ret[] = array(
        'realm'         => Access::REALM_SITE,
        'gid'           => $siteId,
        'grant_view'    => 1,
        'grant_update'  => (int)!$isGlobal,
        'grant_delete'  => (int)!$isGlobal,
        'priority'      => Access::PRIORITY_DEFAULT,
      );
    }
  }

  return $ret;
}

/**
 * Implements hook_node_grants().
 */
function ucms_site_node_grants($account, $op) {

  $cache = &drupal_static(__FUNCTION__, []);

  if (isset($cache[$account->uid][$op])) {
    return $cache[$account->uid][$op];
  }

  $ret  = [];

  // Deal with specific user rights.
  switch ($op) {

    case Access::OP_VIEW:
      if (user_access(Access::PERM_GLOBAL_VIEW)) {
        $ret[Access::REALM_GLOBAL] = [Access::GID_DEFAULT];
      }
      if (user_access(Access::PERM_GLOBAL_LABELED_VIEW)) {
        $ret[Access::REALM_GLOBAL_LABELED] = [Access::GID_DEFAULT];
      }
      break;

    case Access::OP_UPDATE:
    case Access::OP_DELETE:
      if (user_access(Access::PERM_GLOBAL_EDIT)) {
        $ret[Access::REALM_GLOBAL] = [Access::GID_DEFAULT];
      }
      if (user_access(Access::PERM_GLOBAL_LABELED_EDIT)) {
        $ret[Access::REALM_GLOBAL_LABELED] = [Access::GID_DEFAULT];
      }
      break;
  }

  $site = ucms_site_finder()->getContext();

  // Most complex part of this, deal with user's sites (the ones he's
  // webmaster of): states here apply only for the user's sites, and
  // not for public or global content.
  $states = [];

  switch ($op) {

    case Access::OP_VIEW:
      $states = [State::ARCHIVE, State::INIT, State::OFF, State::ON];
      break;

    default:
      $states = [State::INIT, State::OFF, State::ON];
      break;
  }

  // Hate to do a SQL query in such hook, but hopefully this will ever
  // be run only once in the whole amount of time this HTTP request will
  // run (yay).
  $q = db_select('ucms_site_access', 'usa');
  $q->join('ucms_site', 'us', "usa.site_id = us.id");
  $q->fields('usa', ['site_id']);
  $q->condition('us.state', $states);
  $q->condition('usa.uid', $account->uid);

  if ($site) {

    // This is frontend, and we need to exclude everything else.
    $siteIdList = $q
      ->condition('usa.uid', $site->id)
      ->range(0, 1)
      ->execute()
      ->fetchCol()
    ;

    // Note that if the site is public, we should also add the associated
    // public realm to everyone, no matter their user access rights.
    if (State::ON == $site->state) {
      $ret[Access::REALM_PUBLIC] = [Access::GID_DEFAULT];
    }

  } else {
    // Else we are on the master site backend.
    $siteIdList = $q->execute()->fetchCol();
  }

  if ($siteIdList) {
    $ret[Access::REALM_SITE] = $siteIdList;
  }

  return $cache[$account->uid][$op] = $ret;
}

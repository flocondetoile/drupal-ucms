<?php
/**
 * @file
 * UCMS - Layout management module.
 *
 * For the sake of consistency, layouts cannot be nodes, otherwise layouts
 * could be embeded into layouts, which would make a serious and non human
 * comprehensible layout-ception. Problem with this model is that we need
 * to implement by ourselves the access API for layouts, but this is the
 * only custom access API that will be implemented at all.
 *
 * @todo
 *   - better AJAX/REST requests handling
 *   - more detailed data structure (options, status)
 *   - alteration for access checks
 *   - preview mode (display unauthorized or unpublished content)
 *   - non AJAX edit forms for accessibility
 *   - regions filtering (per-theme global configuration) and checks
 *   - unit testing (sorry should have done that earlier).
 */

use MakinaCorpus\Ucms\Layout\Context;
use MakinaCorpus\Ucms\Layout\Item;
use MakinaCorpus\Ucms\Layout\Layout;

/**
 * Implements hook_menu().
 */
function ucms_layout_menu() {
  $items = [];

  // Structure related configuration for administrator.
  $items['admin/structure/layout'] = [
    'title'             => "Layout management",
    'description'       => "Manage usable regions layouts and site wide configuration.",
    'page callback'     => 'ucms_layout_admin_structure',
    'access arguments'  => ['administer content types'],
    'file'              => 'ucms_layout.admin.inc',
    'type'              => MENU_NORMAL_ITEM,
  ];
  $items['admin/structure/layout/%ucms_layout_theme'] = [
    'title callback'    => 'ucms_layout_theme_title',
    'title arguments'   => [3],
    'page callback'     => 'sf_dic_page_form',
    'page arguments'    => ['MakinaCorpus\Ucms\Layout\Admin\ThemeRegionsForm', 3],
    'access arguments'  => ['administer content types'],
    'type'              => MENU_CALLBACK | MENU_VISIBLE_IN_BREADCRUMB,
  ];

  // AJAX endpoints.
  $items['admin/ucms/layout/%ucms_layout_temporary/add'] = [
    'page callback'     => 'ucms_layout_ajax_region_item_add',
    'page arguments'    => [3],
    'access callback'   => 'ucms_layout_access',
    'access arguments'  => ['update', 3],
    'file'              => 'ucms_layout.ajax.inc',
    'type'              => MENU_CALLBACK,
  ];
  $items['admin/ucms/layout/%ucms_layout_temporary/remove'] = [
    'page callback'     => 'ucms_layout_ajax_region_item_remove',
    'page arguments'    => [3],
    'access callback'   => 'ucms_layout_access',
    'access arguments'  => ['update', 3],
    'file'              => 'ucms_layout.ajax.inc',
    'type'              => MENU_CALLBACK,
  ];
  $items['admin/ucms/layout/%ucms_layout_temporary/move'] = [
    'page callback'     => 'ucms_layout_ajax_region_item_move',
    'page arguments'    => [3],
    'access callback'   => 'ucms_layout_access',
    'access arguments'  => ['update', 3],
    'file'              => 'ucms_layout.ajax.inc',
    'type'              => MENU_CALLBACK,
  ];

  return $items;
}

/**
 * Menu helper: ensures a theme exist
 *
 * @param string $theme
 *   Theme name.
 *
 * @return string
 *   Theme name if exists and enabled, false otherwise.
 */
function ucms_layout_theme_load($theme) {
  $themes = system_list('theme');

  return (isset($themes[$theme]) && $themes[$theme]->status) ? $theme : false;
}

/**
 * Menu helper.
 *
 * @param string $theme
 *   Theme name.
 *
 * @return string
 *   The theme edit page title.
 */
function ucms_layout_theme_title($theme) {
  $themes = system_list('theme');

  if (isset($themes[$theme])) {
    return t("Edit @theme theme regions", ['@theme' => $themes[$theme]->info['name']]);
  }

  return t("Edit theme regions");
}

/**
 * Get enabled regions for the given theme.
 *
 * @param string $theme
 *   Theme name.
 *
 * @return string[]
 *   Keys are region names, values region names.
 */
function ucms_layout_theme_region_list($theme) {
  $regions = variable_get('ucms_layout_regions_' . $theme);
  if (null === $regions) {
    $regions = array_keys(system_region_list($theme));
  }
  return drupal_map_assoc($regions);
}

/**
 * Menu helper: load layout instance in potential temporary context.
 */
function ucms_layout_temporary_load($id) {
  $context = ucms_layout_context_get();
  if ($context->isTemporary()) {
    $layout = $context->getCurrentLayout();
    if ($layout instanceof Layout) {
      return $layout;
    }
  }
  return false; // Strict false because null passes, phoque.
}

/**
 * Get current contextual layout.
 *
 * @return Context
 */
function ucms_layout_context_get() {
  static $init = false;

  $context = \Drupal::service('ucms_layout.context');

  // @todo Find a better way.
  if (!$init) {
    ucms_layout_context_init($context);
    $init = true;
  }

  return $context;
}

/**
 * Implements hook_theme().
 */
function ucms_layout_theme() {
  return [
    'ucms_layout_item' => [
      'variables' => ['nid' => null, 'node' => null, 'view_mode' => 'teaser'],
      'template'  => 'ucms-layout-item',
    ],
    'ucms_layout_region' => [
      'variables' => ['items' => [], 'name' => 'content'],
      'template'  => 'ucms-layout-region',
    ],
  ];
}

/**
 * Implements hook_node_load().
 */
function ucms_layout_node_load($node) {
  return;
  // @todo
  //   This should be moved out into lazy code in the storage...
  //   This won't work with entitycache and should be deported.
  // Sorry, query... But at least, only when necessary.
  // Please note that the composite context fully depends on site, and not only
  // on node, so you cannot possibly load it another way than using the context.
  if (($object = menu_get_object()) && $node->nid == $object->nid && ($site = ucms_site_storage()->getContext())) {
    // Do not embed the original load into a transaction to avoid locking.
    $id = (int)db_query("SELECT id FROM {ucms_layout} WHERE nid = :nid", $node->nid)->fetchField();
    if (!$id) {
      try {
        $tx = db_transaction();
        $id = (int)db_select('ucms_layout', 'ul')
          ->fields('ul', ['id'])
          ->condition('ul.nid', $node->nid)
          ->condition('ul.site_id', $site->id)
          ->execute()
          ->fetchField()
        ;
        // If another transaction happened before our first select and this
        // transaction, we will have an id here, then just close the transaction
        // and use this id.
        if (!$id) {
          $id = (int)db_insert('ucms_layout')->fields(['nid' => $node->nid, 'site_id' => $site->id])->execute();
        }
        unset($tx); // Explicit commit.
      } catch (Exception $e) {
        if ($tx) { // Exception might happen without transaction started.
          try {
            $tx->rollback();
          } catch (Exception $e2) {
            watchdog_exception(__FUNCTION__, $e2); // You're fucked.
          }
        }
        watchdog_exception(__FUNCTION__, $e);
        throw $e; // You shall not pass.
      }
    }
    $node->layout_id = $id;
  }
}

/**
 * Initialize context.
 */
function ucms_layout_context_init(Context $context) {
  // We don't have any choice but loading it this moment since a few other
  // modules might need to check whether the current context is temporary
  // or not, so do it at init.
  // @todo
  //   Later on, fix this.
  if (!path_is_admin(current_path()) &&
      !arg(2) &&
      ($node = menu_get_object()) && !empty($node->layout_id)
  ){
    if (isset($_GET['edit']) && drupal_valid_token($_GET['edit'])) {
      $context->setToken($_GET['edit']);
    } else if ('POST' === $_SERVER['REQUEST_METHOD'] && isset($_POST['token']) && drupal_valid_token($_POST['token'])) {
      $context->setToken($_POST['token']);
    }

    if ($layout = $context->getStorage()->load($node->layout_id)) {
      $context->setCurrentLayout($layout);
    } else {
      $context->setToken(null);
    }
  }
}

/**
 * Implements hook_page_build().
 */
function ucms_layout_page_build(&$page) {
  global $theme;

  $context  = ucms_layout_context_get();
  $layout   = $context->getCurrentLayout();
  $editMode = $context->isTemporary();

  if (!$layout instanceof Layout) {
    return; // No layout on page.
  }

  if ($editMode) {
    drupal_add_js(['ucmsLayout' => [
      'editToken' => $context->getToken(),
      'layoutId' => $layout->getId()
    ]], 'setting');
  }

  foreach (ucms_layout_theme_region_list($theme) as $regionId) {

    $items  = [];
    $region = $layout->getRegion($regionId);

    // Preload all nodes for performance.
    $nodeIdList = $region->getAllNodeIds();

    if ($nodeIdList) {
      $map = node_load_multiple($nodeIdList);

      $map = array_filter($map, function ($node) {
        return node_access('view', $node);
      });

      if (empty($map) && !$editMode) {
        return;
      }

      /* @var $item Item */
      foreach ($region as $item) {
        $nid = $item->getNodeId();
        if (isset($map[$nid])) {
          $items[] = [
            '#theme'      => 'ucms_layout_item',
            '#nid'        => $item->getNodeId(),
            '#node'       => $map[$nid],
            '#view_mode'  => $item->getViewMode(),
          ];
        }
      }
    }

    if ($editMode && empty($items)) {
      // Trick block.module so that it's not "empty"
      $items = ['#markup' => ''];
    }

    if ($items) {
      $page[$regionId] = $items;
    }
  }
}

/**
 * Implements hook_preprocess_block().
 */
function ucms_layout_preprocess_region(&$vars) {
  // Lookup for all blocks, if these are only ucms empty block, add class
  $vars['attributes_array']['data-region'] = $vars['region'];
  if (!empty($vars['elements']['#type'])) {
    $vars['classes_array'][] = 'ucms-layout-empty-block';
  }
  if (!element_children($vars['elements'])) {
    $vars['classes_array'][] = 'ucms-layout-empty-region';
  }
}

/**
 * Implements template_preprocess_HOOK().
 */
function template_preprocess_ucms_layout_item(&$variables) {
  if (isset($variables['node'])) {
    $variables['content'] = node_view($variables['node'], $variables['view_mode']);
  } else {
    $variables['content'] = [];
  }
}

